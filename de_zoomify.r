#!/usr/bin/env Rscript

# Script Info: this program take a folder generated by zoomify and reconstitutes the original image.
	# i: name of folder full of zoomified tiles (will have multiple subdirectories containing tiles, that's OK)
	# o: output filepath for reconstituted jpg
	# Written by John L. Darcy and Solomon Champion, 2018 APR 20

	# to use this script, you need rscript installed (comes with R installation), and
	# the R packages optparse and jpeg.
	# you will also need to add execution privilages for this file. do so in bash with
		# chmod a+x de_zoomify.r

	# to use this script across multiple zoomified folders (each containing tiles for a separate image):
	# for f in *; do
	#	./de_zoomify.r -i $f -o "$f_image.jpg" -n TRUE;
	# done



suppressPackageStartupMessages(require(optparse))
suppressPackageStartupMessages(require(jpeg))

# parse arguments
	option_list <- list(
		make_option(c("-i", "--input"), action="store", default=NA, type='character',
			help="Folder path with zoomified images within (subdirectories OK)"), 
		make_option(c("-o", "--output"), action="store", default=NA, type='character',
			help="Output stitched jpg image filepath"),
		make_option(c("-x", "--xml_fn"), action="store", default="ImageProperties.xml", type='character',
			help="Override xml filename - default is ImageProperties.xml"),
		make_option(c("-n", "--noisy"), action="store", default=FALSE, type='logical',
			help="print out annoying status messages? default is FALSE.")
	)
	opt <- parse_args(OptionParser(option_list=option_list))
	
	#opt <- list(input="~/Desktop/2572/", output="~/Desktop/test2.jpg", xml_fn="ImageProperties.xml")
	noisy <- opt$noisy
	folder_fp <- opt$input
	output_fp <- opt$output
	xml_fp <- paste( folder_fp, "/", opt$xml_fn, sep="")

# read xml file
	xml_line <- scan(file=xml_fp, what=character(), sep=" ")
	# get width, heith, numtiles
	bigwidth <- as.numeric( unlist(strsplit(xml_line[grepl("WIDTH", xml_line)], "="))[2] )
	bigheight <- as.numeric( unlist(strsplit(xml_line[grepl("HEIGHT", xml_line)], "="))[2] )
	bigtiles <- as.numeric( unlist(strsplit(xml_line[grepl("NUMTILES", xml_line)], "="))[2] )

# get each file name
	# get each folder name that's a tilegroup
	tile_folders <- list.files(folder_fp) [grep(pattern="TileGroup", x=list.files(folder_fp))]


	fol <- character()
	fil <- character()

	# for each tile folder, get filenames
	for(tf in tile_folders){
		filenames_tf <- list.files( paste(folder_fp, "/", tf, sep=""))
		fil <- c(fil, filenames_tf)
		fol <- c(fol, rep(tf, length(filenames_tf)))
	}

	# classify each file based on zoom level
	
	file_x <- file_y <- zoomlvl <- rep(0, length(fil))
	for(i in 1:length(fil)){
		filename_i <- fil[i]
		zyx <- unlist(strsplit( unlist(strsplit(filename_i, split="\\.jpg")), split="-") )
		file_x[i] <- zyx[2]
		file_y[i] <- zyx[3]
		zoomlvl[i] <- zyx[1]
	}

	fileinfo <- data.frame(fol, fil, zoomlvl, file_x, file_y, stringsAsFactors=F)

# get rid of all files that aren't max zoomlevel
	# get rid of thumbs
	fileinfo <- fileinfo[  grep(fileinfo$fil, pattern="thumbs", ignore.case=T, invert=T) ,]
	max_zoom_lvl <- max(as.numeric(fileinfo$zoomlvl))
	fileinfo <- fileinfo[fileinfo$zoomlvl == max_zoom_lvl, ]
	
	# fix stupid file_x and file_y to be numeric
	fileinfo$file_x <- as.numeric(fileinfo$file_x)
	fileinfo$file_y <- as.numeric(fileinfo$file_y)


# sort fileinfo by matrix fill order
	fileinfo <- fileinfo[order( fileinfo$file_y), ]
	fileinfo <- fileinfo[order( fileinfo$file_x), ]


# make blank matrix for whole thing
	bigmat_b <-  bigmat_g <- bigmat_r <- matrix(nrow=bigheight, ncol=bigwidth, data=0)

for(i in 1:nrow(fileinfo)){
	fp_i <- paste( folder_fp, fileinfo$fol[i], fileinfo$fil[i], sep="/")
	pic_i <- readJPEG(fp_i)

	pic_i_r <- pic_i[ , , 1]
	pic_i_g <- pic_i[ , , 2]
	pic_i_b <- pic_i[ , , 3]

	# calculate top-left position of pic_i in bigmat
	startrow <- (fileinfo$file_y[i] * 256) + 1
	startcol <- (fileinfo$file_x[i] * 256) + 1

	# width and height of pic_i
	height_i <- nrow(pic_i_r)
	width_i <- ncol(pic_i_r)

	row_inds_i <- startrow:(startrow + height_i - 1)
	col_inds_i <- startcol:(startcol + width_i - 1)

	bigmat_r[ row_inds_i, col_inds_i ] <- pic_i_r
	bigmat_g[ row_inds_i, col_inds_i ] <- pic_i_g
	bigmat_b[ row_inds_i, col_inds_i ] <- pic_i_b

	if(noisy){print(paste(i, "out of", nrow(fileinfo)))}
}

# combine bigmats into a jpeg

output <- array( c(bigmat_r, bigmat_g, bigmat_b) , dim=c(dim(bigmat_r), 3) )

writeJPEG(output, target=output_fp)















